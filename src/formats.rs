use std::{hash::{DefaultHasher, Hash, Hasher}, io::Write, marker::PhantomData};
use serde::Serialize;

#[allow(unused_imports)]
use crate::UtcHourly;

/// Binary data version string.
pub const BINARY_VERSION: &str = "1.0";
const BINARY_ALIGN: u32 = size_of::<u32>() as _;
const BINARY_PADDING: [u8; BINARY_ALIGN as usize] = [0xff; BINARY_ALIGN as usize];
const BINARY_FRAME_START: &[u8] = b"FRME";

/// This trait contains functions that describe the file extension,
/// inter-frame delimiter and header initializer for a data storage
/// type.
/// [UtcHourly] only works with data types that implement this trait.
pub trait FmtInfo {
    /// Delimiter between each frame
    fn delimiter() -> &'static [u8];
    /// File extension of frame
    fn extension() -> &'static str;
    /// Initialize a new file
    ///
    /// # Arguments
    /// - `writer`: Where header data is written
    /// - `progname`: Program that is writing this data file
    fn initialize<W>(writer: W, progname: &str) -> std::io::Result<W>
    where
        W: Write;
    /// Hash of the type name
    fn type_hash() -> u64 {
        let mut hasher = DefaultHasher::new();
        std::any::type_name::<Self>().hash(&mut hasher);
        hasher.finish()
    }
}

#[derive(Debug)]
/// Binary data store marker.
pub struct Binary {}

impl FmtInfo for Binary {
    fn delimiter() -> &'static [u8] {
        b""
    }

    fn extension() -> &'static str {
        "bin"
    }

    fn initialize<W: Write>(writer: W, progname: &str) -> std::io::Result<W> {
        let fmt = format!(
            "
# This file is generated by {} using binary format version {}.
# The binary file is aligned to 4 byte boundaries.
# The file format is described as follows:
# <Ofst 0: Frame size (4 LE bytes, aligned to 4 bytes)>
# <Ofst 4: Payload size (4 LE bytes)>
# <Ofst 8: Data[0..Payload Size + 1]>
# <Ofst Payload Size + 1: Padding[FF; Payload Size % 4]>
# <Next Frame Start>\n",
            progname, BINARY_VERSION
        );
        store_binary(writer, fmt.as_bytes())
    }

    fn type_hash() -> u64 {
        // Hash of the type name
        let mut hasher = DefaultHasher::new();
        "BINARY".hash(&mut hasher);
        hasher.finish()
    }
}

#[derive(Debug)]
/// JSONL data store marker.
pub struct Json<T> {
    _marker: PhantomData<T>,
}

#[derive(Debug, Serialize)]
/// JSONL data file header.
pub struct JsonHeader {
    header: String,
}

impl JsonHeader {
    fn new(progname: &str) -> Self {
        Self {
            header: format!("This file is created by {progname}."),
        }
    }
}

impl<T> FmtInfo for Json<T> {
    fn delimiter() -> &'static [u8] {
        b"\n"
    }

    fn extension() -> &'static str {
        "Json"
    }

    fn initialize<W: Write>(mut writer: W, progname: &str) -> std::io::Result<W> {
        let repr = serde_json::to_string(&JsonHeader::new(progname))
            .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidInput, err))?;
        writer.write_all(repr.as_bytes())?;
        writer.write_all(b"\n")?;
        writer.flush()?;
        Ok(writer)
    }

    fn type_hash() -> u64 {
        // Hash of the type name
        let mut hasher = DefaultHasher::new();
        "JSONL".hash(&mut hasher);
        hasher.finish()
    }
}

pub(crate) fn store_binary<W>(mut writer: W, data: &[u8]) -> Result<W, std::io::Error>
where
    W: Write,
{
    let data_size = data.len() as u32;
    let padding = BINARY_ALIGN - (data_size % BINARY_ALIGN);
    let frame_size = data_size
        .checked_add(size_of::<u32>() as u32 + padding) // payload size + padding
        .ok_or(std::io::Error::new(
            std::io::ErrorKind::OutOfMemory,
            "Frame size too large",
        ))?;
    debug_assert!(
        frame_size % BINARY_ALIGN == 0,
        "Frame size {frame_size} is not {BINARY_ALIGN}-byte aligned: {data_size} + {padding}"
    );
    writer.write_all(BINARY_FRAME_START)?; // write frame start
    writer.write_all(&frame_size.to_le_bytes())?; // write frame size
    writer.write_all(&data_size.to_le_bytes())?; // write header size
    writer.write_all(data)?; // write the data
    writer.write_all(&BINARY_PADDING[..padding as usize])?; // write the padding
    writer.flush()?;
    Ok(writer)
}
